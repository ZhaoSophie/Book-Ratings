<!DOCTYPE html>
<html>

<head>
  <title>What factors impact the rating of a book?</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: #bbb;
    }

    body,
    html {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
  </style>
</head>

<body>
  <svg height="460" width="300" style="border: 1px solid black;">
    <g stroke="#6e2c00" fill="#6e2c00">

      <!-- Shelf pillars -->
      <rect x="20" y="60" width="10" height="380" />
      <rect x="270" y="60" width="10" height="380" />

      <!-- Horizontal shelves -->
      <rect x="20" y="60" width="260" height="10" />
      <rect x="20" y="150" width="260" height="10" />
      <rect x="20" y="240" width="260" height="10" />
      <rect x="20" y="330" width="260" height="10" />
      <rect x="20" y="420" width="260" height="10" />

    </g>
  </svg>

  <svg id="pages" width="600" height="600">
    <!-- <text id="title" x="400" y="5" text-anchor="middle" alignment-baseline="hanging"></text> -->
  </svg>

  <script>
    const requestData = async function () {
      let data = await d3.csv('../data/books.csv');
      console.log(data);

      let num_genres = new Map() // map of genres to # of books
      let genres_books = new Map()
      let genres = ['Romance', 'Mystery', 'Historical Fiction', 'Science Fiction', 'Nonfiction']

      // The books where one of the genres is among the top 5 genres 
      let top_genre_books = []

      genres.forEach((g) => {
        num_genres.set(g, 0);
      })

      data.forEach((d, i) => {
        let genres_list = d['genres'].slice(2, -2).split("', '") // get list of genres for book
        let len = genres_list.length;

        // find first genre that's in top 5 genres
        var i = 0;
        let genre = genres_list[i];
        while (!num_genres.has(genre)) {
          i += 1;
          if (i == len) {
            genre = "";
            break;
          } else {
            genre = genres_list[i];
          }
        }

        // at this point, 'genre' is the genre (within top 5) of the book
        d['top_genre'] = genre; // adding the top genre as a new field

        // Reformatting some data
        convert_to_num = ['current_readers', 'num_pages', 'num_ratings', 'num_reviews',
          'price', 'rating_score', 'want_to_read'];
        convert_to_num.forEach((category, i) => {
          d[category] = Number(d[category]);
        });

        const parseDate = d3.timeParse("%B %e, %Y");
        d['publication_date'] = parseDate(d['publication_date']);

        // fill map with counts of books
        if (genre != "") {
          num_genres.set(genre, num_genres.get(genre) + 1)
        }

        // add valid points to the dataset for scatterplots
        if (genre != "" && d['num_pages'] > 0) {
          top_genre_books.push(d);
        }
      });

      console.log(num_genres);
      console.log(top_genre_books);

      // ----- SCATTERPLOTS -----

      // General dimensions of every scatterplot are the same
      const pages_svg = d3.select('#pages');
      // const legend = d3.select('#legend');
      const width = pages_svg.attr('width');
      const height = pages_svg.attr('height');
      const margins = { top: 40, right: 20, bottom: 60, left: 55 };
      const chartWidth = width - margins.left - margins.right;
      const chartHeight = height - margins.top - margins.bottom;

      // RATINGS VS. NUMBER OF PAGES SCATTERPLOT
      let pages_chartArea = pages_svg.append('g')
        .attr('transform', `translate(${margins.left},${margins.top})`);

      pages_svg.append("text")
        .attr("class", "title")
        .attr("text-anchor", "middle")
        .attr("x", chartWidth / 2 + margins.left)
        .attr("y", 20)
        .text("Rating vs. Number of Pages");

      // create scales
      const pageExtent = d3.extent(top_genre_books, d => d['num_pages']);
      const pageScale = d3.scaleLinear().domain(pageExtent).range([0, chartWidth]);
      const ratingExtent = d3.extent(top_genre_books, d => d['rating_score']);
      const ratingScale = d3.scaleLinear().domain(ratingExtent).range([chartHeight, 0]);
      const genreScale = d3.scaleOrdinal(d3.schemeTableau10);

      let leftGridlines = d3.axisLeft(ratingScale)
        .tickSize(-chartWidth - 10)
        .tickFormat('');
      pages_svg.append('g')
        .attr('class', 'y gridlines')
        .attr('transform', `translate(${margins.left},${margins.top})`)
        .call(leftGridlines);

      let bottomGridlines = d3.axisBottom(pageScale)
        .tickSize(-chartHeight - 10)
        .tickFormat('');
      pages_svg.append('g')
        .attr('class', 'x gridlines')
        .attr('transform', `translate(${margins.left},${chartHeight + margins.top})`)
        .call(bottomGridlines);

      let leftAxis = d3.axisLeft(ratingScale);
      pages_svg.append('g')
        .attr('class', 'y axis')
        .attr('transform', `translate(${margins.left},${margins.top})`)
        .call(leftAxis);

      let bottomAxis = d3.axisBottom(pageScale);
      pages_svg.append('g')
        .attr('class', 'x axis')
        .attr('transform', `translate(${margins.left},${chartHeight + margins.top})`)
        .call(bottomAxis);

      // adding labels
      pages_svg.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "middle")
        .attr("x", -chartHeight / 2 - margins.top)
        .attr("y", 20)
        .attr("transform", "rotate(-90)")
        .text("Rating (out of 5)");

      pages_svg.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "middle")
        .attr("x", chartWidth / 2 + margins.left)
        .attr("y", height - 20)
        .text("Number of Pages");

      let circles = pages_chartArea.selectAll("circle").data(top_genre_books)
        .join("circle")
        .attr("class", d => d['top_genre'])
        .attr("cx", d => pageScale(d['num_pages']))
        .attr("cy", d => ratingScale(d['rating_score']))
        .attr("r", 5)
        .style("fill", d => genreScale(d['top_genre']))
        .style("opacity", 0.4);

      pages_chartArea.raise();
    }

    requestData();
  </script>
</body>

</html>