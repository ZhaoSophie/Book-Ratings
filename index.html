<!DOCTYPE html>
<html>

<head>
  <title>What factors impact the rating of a book?</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    div {
      display: flex;
      justify-content: center;
    }

    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: #bbb;
    }

    body,
    html {
      /* display: flex; */
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 30px;
    }

    button {
      padding: 10px;
      border-radius: 5px;
      border: 1px solid gray;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }

    button:hover {
      border: 1px solid black;
      /* Darker blue when clicked */
      transform: scale(0.98);
      /* Thicker border on hover */
    }


    .page-title {
      font-size: 2.5rem;
      font-weight: bold;
      text-align: center;
      margin: 20px;
      padding: 20px;
      background-color: #f5f5f5;
      color: #333;
      border: 2px solid #ccc;
      border-radius: 10px;
      box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.2);
    }
  </style>
</head>

<body>
  <h1 class="page-title">What factors impact the rating of a book?</h1>
  <div>
    <svg id="shelf" height="600" width="600" style="border: 1px solid black;">
      <g stroke="#6e2c00" fill="#6e2c00">

        <!-- Shelf pillars -->
        <rect x="30" y="80" width="25" height="500" />
        <rect x="555" y="80" width="25" height="500" />

        <!-- Horizontal shelves -->
        <rect x="30" y="80" width="550" height="25" />
        <rect x="30" y="180" width="550" height="25" />
        <rect x="30" y="280" width="550" height="25" />
        <rect x="30" y="380" width="550" height="25" />
        <rect x="30" y="480" width="550" height="25" />
        <rect x="30" y="580" width="550" height="25" />

      </g>
    </svg>


  </div>
  <p>Our bookshelf visualization shows how the ratings of books compare between genres. The average rating of our
    dataset was calculated for each genre and sorted so that the top shelf has the highest-rated genre and the bottom
    shelf has the lowest-rated genre. The higher-rated books are taller and have a darker hue, while the lower-rated
    books are shorter and have a lighter hue, as shown in the legend above. However, it's important
    to note that this correlation does not imply causation, which means the genre doesn't necessarily positively or
    negatively impact the rating of a book. It appears
    that historical fiction has the highest-rated books on average, and mystery has the lowest. </p>

  <script>
    const legendSvg = d3.select("#shelf");
    const legendWidth = +legendSvg.attr("width");
    const legendHeight = +legendSvg.attr("height");

    const lowRatedColor = "white";
    const highRatedColor = "grey";

    const bookWidthLegend = 10;
    const bookHeightLegendMin = 20;
    const bookHeightLegendMax = 70;
    const padding = 20;

    const legendXStart = legendWidth - 150;
    const legendYStart = padding;

    // Low-rated book label
    legendSvg.append("text")
      .attr("x", 300)
      .attr("y", 65)
      .style("text-anchor", "middle")
      .style("font-size", "12px")
      .text("Low-rated book:");

    // Low-rated book rectangle
    legendSvg.append("rect")
      .attr("x", 350)
      .attr("y", 55)
      .attr("width", bookWidthLegend)
      .attr("height", bookHeightLegendMin)
      .style("fill", lowRatedColor)
      .style("stroke", "black");

    // High-rated book label
    legendSvg.append("text")
      .attr("x", 450)
      .attr("y", 65)
      .style("text-anchor", "middle")
      .style("font-size", "12px")
      .text("High-rated book:");

    // High-rated book rectangle
    legendSvg.append("rect")
      .attr("x", 500)
      .attr("y", 5)
      .attr("width", bookWidthLegend)
      .attr("height", bookHeightLegendMax)
      .style("fill", highRatedColor)
      .style("stroke", "black");
  </script>


  <h2>The scatterplots for the data: </h2>
  <div>
    <button id="Romance">Romance</button>
    <button id="Mystery">Mystery</button>
    <button id="Historical_Fiction">Historical Fiction</button>
    <button id="Science_Fiction">Science Fiction</button>
    <button id="Nonfiction">Nonfiction</button>
    <button id="All_Genres">All Genres</button>
  </div>
  <div>
    <svg id="num_pages" width="600" height="600"></svg>
  </div>
  <div>
    <svg id="publication_date" width="600" height="600"></svg>
  </div>
  <div>
    <svg id="price" width="600" height="600"></svg>
  </div>
  <div>
    <svg id="number_of_awards" width="600" height="600"></svg>
  </div>
  <div>
    <svg id="authors" width="600" height="600"></svg>
    <text id="label" x="50" y="5" text-anchor="start" alignment-baseline="hanging"></text>
  </div>

  <script>
    const svg = d3.select("svg");
    const width = svg.attr("width");
    const height = svg.attr("height");

    const spaceBetweenBooks = 1;
    const booksPerShelf = 50;
    const bookWidth = (width - 2 * 55) / booksPerShelf - 1;
    const shelfHeight = 100;
    const minHeight = bookWidth * 2;
    const maxHeight = shelfHeight - 25;

    // helper function: interactivity for books
    function textCutoff(text, maxLength) {
      if (text.length > maxLength) {
        return text.substring(0, maxLength - 2).concat("...")
      } else {
        return text
      }
    }

    // helper functioN: adds labels for each shelf which genre the books are
    function addText(genre, shelfposition = 130) {
      svg.append("text")
        .attr("x", 60)
        .attr("y", shelfposition)
        .text(genre)
        .style("font-size", "14px")
        .style("font-weight", "bold")
        .style("fill", "white");
    }



    // helper function: one compact function that parses all dates/times/years
    // possible toFormats: 'year' i.e. 2024, 'date' i.e. Tue Jun 13 2017 00:00:00 GMT-0400 (Eastern Daylight Time) 
    function parseTime(date, toFormat) {
      let parser = d3.timeFormat();
      if (toFormat == 'year') {
        parser = d3.timeFormat("%Y");
      }
      else if (toFormat == 'date') {
        parser = d3.timeParse("%d-%b-%y");
      }
      else if (toFormat == 'str') {
        parser = d3.utcFormat("%B %d, %Y");
      }
      return parser(date);
    }


    // helper function: darken a color
    // inspired by lighten(color) from Prof. Rzeszotarski
    function darken(color, amount) {
      let hclColor = d3.hcl(color);
      let luma = Math.min(130, hclColor.l - amount);
      return d3.rgb(d3.hcl(hclColor.h, hclColor.c, luma));
    }

    // helper function: returns label without _ and capitalized
    function formatLabel(text, type) {
      if (text == "num_pages") {
        text = "number_of_pages"
      }
      formatted = text.toLowerCase()
        .split('_')
        .map(s => s.charAt(0).toUpperCase() + s.substring(1))
        .join(' ');

      return formatted
    }

    // helper function: creates rect/text for the hover label over books/circles
    function createHoverLabel(label, uniqueBooks, awards_books) {
      const labelWidth = 250;
      const labelHeight = 110;
      const r = 20;

      label.append("rect")
        .attr("width", labelWidth)
        .attr("height", labelHeight)
        .attr("rx", 10)
        .attr("ry", 10)
        .attr("fill", "#dfd0c0")
        .attr("stroke", "black");

      label.append("text")
        .attr("id", "labelTitle")
        .attr("x", 10)
        .attr("y", 20)
        .style("font-size", "14px")
        .style("font-weight", "bold");

      label.append("text")
        .attr("id", "labelAuthors")
        .attr("x", 10)
        .attr("y", 40)
        .style("font-size", "12px");

      label.append("text")
        .attr("id", "labelGenre")
        .attr("x", 10)
        .attr("y", 60)
        .style("font-size", "12px");

      label.append("text")
        .attr("id", "labelRating")
        .attr("x", 10)
        .attr("y", 80)
        .style("font-size", "12px");

      label.append("text")
        .attr("id", "labelXVar")
        .attr("x", 10)
        .attr("y", 100)
        .style("font-size", "12px");

      label.append("circle")
        .attr("id", "labelAward")
        .attr("cx", labelWidth - r - 15) // Position near bottom-right corner
        .attr("cy", labelHeight - r - 15)
        .attr("r", r)
        .attr("fill", "gold")
        .attr("stroke", "black");

      return label;
    }

    function filterData(data) { }

    const requestData = async function () {
      let data = await d3.csv('data/goodreads_top100_from1980to2023_final.csv');
      let data_awards = await d3.csv('data/books_awards_chars.csv');

      console.log("data", data);
      console.log("data_awards", data_awards);

      let num_genres = new Map() // map of genres to # of books
      let genres_books = new Map()
      let genres = ['Romance', 'Mystery', 'Historical Fiction', 'Science Fiction', 'Nonfiction']

      // The books where one of the genres is among the top 5 genres 
      let top_genre_books = []
      let awards_books = []

      genres.forEach((g) => {
        num_genres.set(g, 0);
      })

      data.forEach((d, i) => {
        let genres_list = d['genres'].slice(2, -2).split("', '") // get list of genres for book
        let len = genres_list.length;

        // find first genre that's in top 5 genres
        var i = 0;
        let genre = genres_list[i];
        while (!num_genres.has(genre)) {
          i += 1;
          if (i == len) {
            genre = "";
            break;
          } else {
            genre = genres_list[i];
          }
        }

        // at this point, 'genre' is the genre (within top 5) of the book
        d['top_genre'] = genre; // adding the top genre as a new field

        // Reformatting some data
        convert_to_num = ['current_readers', 'num_pages', 'num_ratings', 'num_reviews',
          'price', 'rating_score', 'want_to_read'];
        convert_to_num.forEach((category, i) => {
          d[category] = Number(d[category]);
        });

        // date format from excel: e.g. "13-Jun-17"
        d['publication_date'] = parseTime(d['publication_date'], 'date');

        // fill map with counts of books
        if (genre != "") {
          num_genres.set(genre, num_genres.get(genre) + 1)
        }

        // add valid points to the dataset for scatterplots
        if (genre != "" && d['num_pages'] > 0 && d['num_pages'] < 1800
          && parseTime(d['publication_date'], 'year') <= 2024 && d['price'] > 0) {
          top_genre_books.push(d);
        }
      });

      data_awards.forEach((d, i) => {
        let genres_list = d['genres'].slice(2, -2).split("', '") // get list of genres for book
        let len = genres_list.length;

        // find first genre that's in top 5 genres
        var i = 0;
        let genre = genres_list[i];
        while (!num_genres.has(genre)) {
          i += 1;
          if (i == len) {
            genre = "";
            break;
          } else {
            genre = genres_list[i];
          }
        }

        // at this point, 'genre' is the genre (within top 5) of the book
        d['top_genre'] = genre; // adding the top genre as a new field

        // Reformatting some data
        convert_to_num = ['rating'];
        convert_to_num.forEach((category, i) => {
          d[category] = Number(d[category]);
        });

        d['authors'] = d['author'];

        // collect # of awards per book
        d['number_of_awards'] = d['awards'].slice(1, -1).split(',').length;

        // add valid points to the dataset for scatterplots
        if (genre != "" && d['pages'] > 0 && d['price'] > 0 && d['number_of_awards'] > 0) {
          awards_books.push(d);
        }
      });

      console.log("num_genres", num_genres);
      console.log("top_genre_books", top_genre_books);
      console.log("awards_books", awards_books);

      const uniqueBooks = [];
      const seenBooks = new Set();

      top_genre_books.forEach(book => {
        if (!seenBooks.has(book.title)) {
          uniqueBooks.push(book);
          seenBooks.add(book.title);
        }
      })

      // ----- Books on Shelf -----

      // Genre color scale
      // colors based on d3.schemeTableau10, but ordered differently
      // pink, orange, blue, purple, green
      const genreColors = ['#E1575A', '#F28E2C', '#4F79A7', '#AF7AA1', '#58A14E'];
      const genreScale = d3.scaleOrdinal(genres, genreColors);

      // subset of books to be added to the bookshelf
      const booksForShelf = []

      /*
      for each genre, take the first 15 books that have this genre as its top genre
      Note: dataset is sorted by highest number of reviews first
      */
      genres.forEach(genre => {
        let booksInGenre = uniqueBooks.filter(d => (d.top_genre === genre))
          .slice(0, booksPerShelf)
        booksInGenre.sort(function (a, b) {
          return a["publication_date"] - b["publication_date"]
        });
        booksForShelf.push(booksInGenre);
      })
      console.log("booksForShelf", booksForShelf);

      // get average rating per shelf
      const genreRatingsMap = new Map();
      booksForShelf.forEach(genre => {
        let totalRating = 0
        for (let i = 0; i < genre.length; i++) {
          totalRating += genre[i].rating_score
        }
        genreRatingsMap.set(genre[0].top_genre, totalRating / genre.length)
      })

      // turn booksForShelf into a map of genres to the books in the genre
      const shelfMap = new Map()
      booksForShelf.forEach(array => {
        shelfMap.set(array[0].top_genre, array)
      })
      console.log("shelfMap", shelfMap)

      // sort genre list with ratings by highest ratings
      const genreRatingsArr = [...genreRatingsMap.entries()].sort((a, b) => b[1] - a[1])
      console.log("genreRatingsArr", genreRatingsArr)

      const minRating = d3.min(booksForShelf.flat(), d => d.rating_score);
      const maxRating = d3.max(booksForShelf.flat(), d => d.rating_score);
      const heightScale = d3.scaleLinear().domain([minRating, maxRating])
        .range([minHeight, maxHeight])
      const minRatingAll = d3.min(data, d => d.rating_score);
      const maxRatingAll = d3.max(data, d => d.rating_score);
      const bookLightness = d3.scaleLinear().domain([minRatingAll, maxRatingAll])
        .range([1.5, 0.1])
      // add books to the shelf

      let shelves = svg.selectAll("shelf")
        .data(genreRatingsArr)
        .join("g")
        .attr("class", "shelf")
        .attr("transform", (d, i) => `translate(0, ${115 + i * shelfHeight})`);

      let rectangles = shelves.selectAll("rect")
        .data(d => shelfMap.get(d[0]))
        .join("rect")
        .attr("x", (d, i) => 60 + i * (bookWidth + spaceBetweenBooks))
        .attr("y", d => shelfHeight - 30 - heightScale(d.rating_score))
        .attr("width", bookWidth)
        .attr("height", d => heightScale(d.rating_score))
        .attr("fill", d => {
          let bookColor = d3.hsl(genreScale(d.top_genre));
          bookColor.l = bookLightness(d.rating_score);
          return bookColor;
        })
        .attr("stroke", "black")
        .attr("stroke-width", 0.3);

      // Add circles based on the condition
      shelves.selectAll("circle") // Select circles within shelves
        .data(d => shelfMap.get(d[0]))
        .join("circle")
        .attr("cx", (d, i) => 60 + i * (bookWidth + spaceBetweenBooks) + bookWidth / 2)
        .attr("cy", d => shelfHeight - 35)
        .attr("r", 3)
        .attr("fill", "gold")
        .style("visibility", d => {
          return awards_books.some(book2 => book2.title === d.title && book2.number_of_awards > 0)
            ? "visible"
            : "hidden";
        });

      let shelfposition = 198;
      genreRatingsArr.forEach(genre => {
        addText(genre[0], shelfposition);
        shelfposition += 100;
      });

      // adding Title to visualization
      svg.append("text")
        .attr("x", 10)
        .attr("y", 40)
        .text("Ratings vs. Genre:")
        .style("font-size", "21px")
        .style("font-weight", "bold");

      // created tan label when mouse hovers over book
      const label = createHoverLabel(
        svg.append("g").style("visibility", "hidden"),
        uniqueBooks,
        awards_books);

      // mouseover
      rectangles.on("mouseover", function (event) {
        let book = d3.select(this).datum();

        d3.select(this)
          .transition().duration(200)
          .attr("stroke", "black")
          .attr("stroke-width", 3);

        label.select("#labelTitle").text(`Title: ${textCutoff(book.title, 30)}`);
        label.select("#labelAuthors").text(`Author: ${book.authors}`);
        label.select("#labelGenre").text(`Genre: ${book.top_genre}`);
        label.select("#labelRating").text(`Rating: ${book.rating_score}`);
        label.select("#labelXVar").text(`Publication Year: ${parseTime(book.publication_date, 'year')}`);
        if (awards_books.some(book2 => book2.title === book.title && book2.number_of_awards > 0)) {
          console.log("book2.title", book.title)
          label.select("#labelAward").style('visibility', 'visible');
        } else {
          label.select("#labelAward").style('visibility', 'hidden');
        }
        label.style("visibility", "visible");
      });

      // label follows mouse
      rectangles.on("mousemove", function (event) {
        const [mouseX, mouseY] = d3.pointer(event, svg.node());

        // let mouseXTrans
        if (mouseX > width / 2) {
          label.attr("transform", `translate(${mouseX - 275}, ${mouseY - 90})`);
        } else {
          label.attr("transform", `translate(${mouseX + 25}, ${mouseY - 90})`);
        }

      });

      // mouseout
      rectangles.on("mouseout", function (event) {
        let book = d3.select(this).datum();

        d3.select(this)
          .transition().duration(200)
          .attr("stroke", "black")
          .attr("stroke-width", 0.3);

        label.select("#labelAward").style('visibility', 'hidden');
        label.style("visibility", "hidden");

      });

      // ----- SCATTERPLOTS -----
      num_pages_chartArea = createScatterplot(uniqueBooks, awards_books, 'num_pages', d3.scaleLinear(), 'rating_score', genreScale);
      publication_date_chartArea = createScatterplot(uniqueBooks, awards_books, 'publication_date', d3.scaleTime(), 'rating_score', genreScale);
      price_chartArea = createScatterplot(uniqueBooks, awards_books, 'price', d3.scaleLinear(), 'rating_score', genreScale);
      awards_chartArea = createScatterplot(awards_books, awards_books, 'number_of_awards', d3.scaleLog(), 'rating', genreScale);


      const chartAreas = [num_pages_chartArea, publication_date_chartArea, price_chartArea, awards_chartArea];

      // // legend buttons
      genres.forEach(genre => {
        const g = genre.replace(' ', '_');
        d3.select('#' + g)
          .style("background-color", genreScale(genre))
          .on("click", () => {
            // console.log(genre);
            chartAreas.forEach(c => {
              c.selectAll("circle." + g)
                // .transition().duration(1000)
                .style("opacity", 0.6)
                .style("visibility", "visible");

              c.selectAll("circle:not(." + g + ")")
                // .transition().duration(1000)
                .style("visibility", "hidden");
            });
          });
      })

      d3.select('#All_Genres')
        .on("click", () => {
          // console.log("Clear");
          chartAreas.forEach(c => {
            c.selectAll("circle")
              // .transition().duration(400)
              .style("opacity", 0.4)
              .style("visibility", "visible");
          });
        });

      // AUTHORS
      const authors_layer = d3.select("#authors").append("g");
      const authors_width = d3.select("#authors").attr("width");
      const authors_height = d3.select("#authors").attr("height");

      let authors_data = await d3.csv('data/authors.csv');
      let authors_1980 = []

      const timeParser = d3.timeParse('%Y-%m-%d')
      authors_data.forEach(d => {
        let birthyear = timeParser(d['born']).getFullYear()
        d['born'] = birthyear

        if (birthyear == 1980) {
          authors_1980.push(d)
        }
      })

      // Create links
      let authors_genres = new Map()
      authors_1980.forEach(d => {
        let genre = d['genre'].split(",")[0]
        d['g'] = genre
        let name = d['name']

        if (authors_genres.has(genre)) {
          authors_genres.get(genre).push(name)
        } else {
          authors_genres.set(genre, [name])
        }
      })

      console.log("authors_genres", authors_genres)

      let authors_links = []

      authors_genres.forEach((authors, genre) => {
        for (let i = 0; i < authors.length - 1; i++) {
          for (let j = i + 1; j < authors.length; j++) {
            authors_links.push({ "source": authors[i], "target": authors[i + 1] })
            authors_links.push({ "source": authors[i], "target": authors[j] })
          }
        }
      })

      // console.log(authors_1980)

      // for (let i = 0; i < authors_1980.length - 1; i++) {
      //   for (let j = i+1; j < authors_1980.length; j++) {
      //     authors_links.push({"source": authors_1980[i], "target": authors_1980[j]})
      //   }
      // }

      let authors = {}
      authors['nodes'] = authors_1980
      authors['links'] = authors_links

      console.log("authors", authors);

      var nodes = authors.nodes;
      var links = authors.links;

      // const valueExtent = d3.extent(links, d => d.value)
      // const valueScale = d3.scaleLinear()
      //                       .domain(valueExtent)
      //                       .range([1, 5])

      // const colorScale = d3.scaleOrdinal(d3.schemeCategory10)

      var simulation = d3.forceSimulation()
        .nodes(nodes)
        .force("links", d3.forceLink()
          .links(links)
          .id(d => d.name))
        .force("repulse", d3.forceManyBody().strength(-5))
        .force("center", d3.forceCenter(width / 2.0, height / 2.0))
        .on("tick", render)

      function render() {
        let edges = authors_layer.selectAll("line.link")
          .data(links)
          .join(
            enter => enter.append("line")
              .attr("class", "link")
              .attr("stroke", "#e0e0e0")
              .attr("stroke-width", 1)
          )
          .attr("x1", d => d.source.x)
          .attr("x2", d => d.target.x)
          .attr("y1", d => d.source.y)
          .attr("y2", d => d.target.y)

        let circles = authors_layer.selectAll("circle.node")
          .data(nodes)
          .join(
            enter => enter.append("circle")
              .attr("class", "node")
              .attr("cx", 0)
              .attr("cy", 0)
              .attr("r", 5)
              .attr("fill", d => {
                if (d['gender'] == "male") {
                  return "#99d6ff"
                } else {
                  return "#ffceea"
                }
              })
              .attr("stroke", "black")
              .attr("stroke-width", 0.5)
              .call(d3.drag().on("start", dragstart)
                .on("drag", dragging)
                .on("end", dragend))
          )
          .attr("transform", d => `translate(${d.x}, ${d.y})`)
      }

      render();

      var genre_label = authors_layer.append("text").attr("id", "label");

      function dragstart(event, d) {
        if (!event.active) {
          genre_label.text(d.g)
          simulation.alphaTarget(0.08).restart()
        }

        d.fx = event.x
        d.fy = event.y

        genre_label.attr("x", event.x + 10).attr("y", event.y);

      }

      function dragging(event, d) {
        d.fx = event.x;
        d.fy = event.y;
        genre_label.attr("x", event.x + 10).attr("y", event.y);
      }

      function dragend(event, d) {
        if (!event.active) {
          simulation.alphaTarget(0);
          genre_label.text("");
        }

        d.fx = null;
        d.fy = null;
      }

    }

    function createScatterplot(books, awards_books, x_var, x_scale_func, y_var, genreScale) {
      // General dimensions of every scatterplot are the same
      const svg = d3.select('#' + x_var);
      const width = svg.attr('width');
      const height = svg.attr('height');
      const margins = { top: 40, right: 20, bottom: 60, left: 55 };
      const chartWidth = width - margins.left - margins.right;
      const chartHeight = height - margins.top - margins.bottom;

      let chartArea = svg.append('g')
        .attr('transform', `translate(${margins.left},${margins.top})`);

      svg.append("text")
        .attr("class", "title")
        .attr("text-anchor", "middle")
        .attr("x", chartWidth / 2 + margins.left)
        .attr("y", 20)
        .text(formatLabel(y_var, "title") + " vs. " + formatLabel(x_var, "title"));

      // create scales
      const xExtent = d3.extent(books, d => d[x_var]);
      const xScale = x_scale_func.domain(xExtent).range([0, chartWidth]);
      const yExtent = d3.extent(books, d => d[y_var]);
      const yScale = d3.scaleLinear().domain(yExtent).range([chartHeight, 0]);

      let leftGridlines = d3.axisLeft(yScale)
        .tickSize(-chartWidth - 10)
        .tickFormat('');
      svg.append('g')
        .attr('class', 'y gridlines')
        .attr('transform', `translate(${margins.left},${margins.top})`)
        .call(leftGridlines);

      let bottomGridlines = d3.axisBottom(xScale)
        .tickSize(-chartHeight - 10)
        .tickFormat('');
      svg.append('g')
        .attr('class', 'x gridlines')
        .attr('transform', `translate(${margins.left},${chartHeight + margins.top})`)
        .call(bottomGridlines);

      let leftAxis = d3.axisLeft(yScale);
      svg.append('g')
        .attr('class', 'y axis')
        .attr('transform', `translate(${margins.left},${margins.top})`)
        .call(leftAxis);

      let bottomAxis = d3.axisBottom(xScale);
      svg.append('g')
        .attr('class', 'x axis')
        .attr('transform', `translate(${margins.left},${chartHeight + margins.top})`)
        .call(bottomAxis);

      // adding axis titles
      svg.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "middle")
        .attr("x", -chartHeight / 2 - margins.top)
        .attr("y", 20)
        .attr("transform", "rotate(-90)")
        .text(formatLabel(y_var, "axis"));

      svg.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "middle")
        .attr("x", chartWidth / 2 + margins.left)
        .attr("y", height - 20)
        .text(formatLabel(x_var, "axis"));

      let circles = chartArea.selectAll("circle").data(books)
        .join("circle")
        .attr("id", d => d['title'].replaceAll(' ', '_'))
        .attr("class", d => d['top_genre'].replace(' ', '_'))
        .attr("cx", d => xScale(d[x_var]))
        .attr("cy", d => yScale(d[y_var]))
        .attr("r", 5)
        .style("fill", d => genreScale(d['top_genre']))
        .style("opacity", 0.4);

      chartArea.raise();

      // add label when hovering over circle

      // created tan label when mouse hovers over book
      const label = createHoverLabel(
        svg.append("g").style("visibility", "hidden"),
        books,
        awards_books);

      circles.on("mouseover", function (event) {
        let circle = d3.select(this);
        let book = circle.datum();
        let title = book['title'];
        let authors = book['authors'];
        let genre = book['top_genre'];
        let xVarFormatted = formatLabel(x_var, 'label');
        let xVarVal = book[x_var];
        if (x_var == 'publication_date') {
          xVarVal = parseTime(xVarVal, 'str');
        } else if (x_var == 'price') {
          xVarVal = "$" + xVarVal;
        }
        // let isbn = book['isbn']; // used as id for each circle

        circle_x = circle.attr('cx');
        circle_y = circle.attr('cy');

        circle.raise()
          .transition().duration(200)
          .attr("r", 8)
          .attr("stroke-width", 1)
          .attr("stroke", d => darken(genreScale(d['top_genre']), 30))
          .style("opacity", 1)
          .style("fill", d => darken(genreScale(d['top_genre']), 10));

        label.select("#labelTitle").text(`Title: ${textCutoff(book['title'], 30)}`);
        label.select("#labelAuthors").text(`Author: ${textCutoff(book['authors'], 35)}`);
        label.select("#labelGenre").text(`Genre: ${book['top_genre']}`);
        label.select("#labelRating").text(`Rating: ${book['rating_score']}`);
        label.select("#labelXVar").text(`${xVarFormatted}: ${xVarVal}`);
        label.style("visibility", "visible");

        const [mouseX, mouseY] = d3.pointer(event, svg.node());

        // let mouseXTrans

        // top right of chart
        if (mouseX > chartWidth / 2 + margins.left && mouseY < chartHeight / 2 + margins.bottom) {
          label.attr("transform", `translate(${mouseX - 275}, ${mouseY - 5})`);
        }
        // top left of chart
        else if (mouseX < chartWidth / 2 + margins.left && mouseY < chartHeight / 2 + margins.bottom) {
          label.attr("transform", `translate(${mouseX + 25}, ${mouseY - 5})`);
        }
        // bottom right of chart
        else if (mouseX > chartWidth / 2 + margins.left && mouseY > chartHeight / 2 + margins.bottom) {
          label.attr("transform", `translate(${mouseX - 275}, ${mouseY - 110})`);
        }
        // bottom left of chart
        else {
          label.attr("transform", `translate(${mouseX + 25}, ${mouseY - 110})`);
        }

        // for debugging purposes
        // console.log(circle.node());
        // console.log("cx:", circle.attr('cx'));
        // console.log("cy:", circle.attr('cy'));

      });


      circles.on("mouseout", function () {
        let circle = d3.select(this);
        circle.transition().duration(200)
          .attr("r", 5)
          .attr("stroke-width", 1)
          .attr("stroke", "none")
          .style("opacity", 0.4)
          .style("fill", d => genreScale(d['top_genre']));

        label.style("visibility", "hidden");
      });

      return chartArea;
    }

    requestData();


  </script>
</body>

</html>